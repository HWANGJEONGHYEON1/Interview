# JAVA
## 자바와 C++ / C 차이점 ?
 - 객체지향 / 절차지향
 - OS에 자유로움 / 자유롭지못함

## 자바 특징
 - 운영체제 독립(JVM)
 - 객체지향 언어, 자동으로 메모리 관리( GC로 인해 비지니스 로직에만 신경쓸 수 있다)
 - 멀티 스레드 쉽게 구현가능 스레드 라이브러리 제공
 - 동적로딩을 지원한다.(각 객체가 필요한 시점에 클래스를 동적로딩)

 ## 접근제어자
 - public + (어디서든)
 - private - (해당 클레스)
 - protected # (동일 패키지 상속 관계)
 - default (동일 패키지)

 ## OOP 특징
 - 추상화 : 사물들의 공통적인 특징을 뽑아내 개념으로 다루는 것
 - 캡슐화 : 외부에서 데이터에 접근 못하게 막는다. 
 - 상속 : 부모 클래스의 메서드를 자식클래스에서 사용가능
 - 다형성 : 서로 다른 클래스의 객체가 같은 메시지를 받았을 때 각자의 방식으로 동작

 ## OOP 5원칙
 - 단일책임원칙 : 객체는 단 하나의 책임만 져야한다.
 - 개방-폐쇄원칙 : 기존의 코드는 변경하지 않으면서 기능을 추가 설계되야한다.
 - 리스코프 치환원칙 : 자식 클래스는 최소한 자신의 부모클래스에서 가능한 행위는 수행할 수 있어야한다.
 - 의존 역전 원칙 : 변화가 거의 없는 것에 의존한다.
 - 인터페이스 분리 원칙 : 클래스는 자신이 사용하지 않는 인터페이스를 구현하지 말아야한다.

 ## 객체지향
 - 실 세계에 물체를 객체로 표현하고. 그것들 중 필요한것을 뽑아 설계 및 구현한다.

 ## static 멤버
 - 클래스 로딩 시 생성
 - 종료될 때 사라짐
 - 객체 생성하지 않고 사용가능
 - 동일한 클래스의 모든 객체들이 공유

 ## final
- 변수나 메서드 또는 클래스가 변경 불가능하다
- 참조는 내용을 바꾸지 주소값은 재할당불가능
- 오버라이드 불가
- 상속 불가능

## 제네릭
- 데이터 타입을 일반화
- 타입의 안정성을 높임(컴파일 시 타입체크)
- 형변환 생략 -> 코드 간결
- 제네릭 eraser : 컴파일 시 자동으로 변환되고 코드 내의 제네릭타입은 제거되어 클래스파일에는 제네릭 타입도 포함되어있지 않다. -> 이유 제네릭을 사용하지않는 코드와 호환하기 위해서

## 자바 가상머신 구성
- 자바 인터프리터
- 클래스로더
- JIT 컴파일러(인터프리터 보완)
- 가비지 컬렉터

## 자바 컴파일 과정
 - .java 를 javac를 통해 .class(바이트코드) 변환 변환한 것을 클래스로더를 통해 JVM에 로드하고 runtime data access를 거쳐 실행엔진으로 간다. 실행엔진은 JIT 컴파일러를 통해 실행된다.

## JVM 메모리
 - stack area
  - 임시 저장공간
  - 매게변수 지역변수 리턴 값저장
 - method area
  - 클래스, 메소드, 멤버변수, 상수 등이 저장
 - heap area
  - new 명령어를 통해 생성된 인스턴스와 참조형 변수정보가 저장, GC 대상 


## 가비지 컬렉션 처리방법
 - 대부분의 객체는 금방 접근 불가능 상태, 오래된 객체에서 젊은 객체로의 참조는 아주 적게존재 가설을 기반으로 만들어짐
 - Young 영역 : 새롭게 생성된 객체는 여기에 존재, 많은 객체들이 생겼다가 사라짐, 객체가 사라질 때 minor GC가 발생했다고함
  - Eden, Survivor(2개) 의 영역
   - Eden이 새로 생긴 객체가 저장, GC가 한번 발생한 후 살아남은 객체는 s1으로 이동, 반복되어 s1이 가득차면 살아남은 객체들은 s2로 이동(s1,s2가 둘 중 하나는 비어있어야함)
   이 과정이 반복되어 Old로 이동
 - Old 영역 : 접근 불가능 상태로 되지 않아 young area에 살아남은 객체가 여기로 복사, 대부분 young area 보다 크게 할당, 크기가 큰 만큼 GC는 적게, 객체가 사라질 때 majorGc라고함
  - Old 영역이 가득차면 GC 실행, GC 방식에 따라 절차가 달라짐.
  - SerialGC(mark-sweep-compact) : old에 살아있는 객체를 mark 힘의 앞부분부터 살아잇는것만 sweep, 마지막 단계에서는 객체가 존재하는 부분과 아닌 부분을 Compaction
  - Parallel GC : GC에서 처리하는  스레드가 여러개 빠르게 처리. GC 메모리가 충분하고 코어 개수가 많을때 유리
  - Parallel Old GC : mark-summary-compact

## 클래스 vs 인스턴스
- 클래스: 객체를 만들어내기 위한 설계도
- 인스턴스 : 클래스에 정의되어있는 객체가 메모리에 할당되어있는 것

## 오버라이딩 vs 오버로딩
- 오버라이딩 : 부모 클래스에서 정의한 것을 자식클래스에서 재정의한 것
- 오버로딩 : 메서드명과 결과값은 같지만 들어가는 파라미터가 다른 것

## 1 call by reference vs 2 call by value
- 1 인자로 받은 값의 주소를 참조하여 직접 영향
- 2 인자로 받은 값을 복사하여 처리

## 인터페이스 vs 추상클래스
- 인터페이스 : 추상메서드, 상수만 포함, 상속받을 클래스에게 구현할 메서드를 알려주어, 목적에 맞게 개발할 수 있도록함, 구현 객체의 같은 동작을 보장하기 위한 목적
- 추상클래스 : 추상메서드를 최소 한개 이상가지고 있는 클래스, 공통된 부분을 추강화하여 상속받는 클래스에게 강제화
- 공통점 : 객체생성불가, 선언만있고, 구현 없음, 자식클래스에게 책임 위임
- 차이점 : 추상클래스는 자식클래스가 구체화하여 그기능을 확장하는데 있지만 인터페이스는 서로 관련없는 클래스에서 공통적으로 사용하는 방식, 구현객체의 같은 동작을 보장

## Collection
- Map : 검색, key,value 형태
  - HashMap
   - 내부 hash 값에 따라 키 순서가 정해짐
   - key,value에 널 허용
   - 비동기처리
   - 시간복잡도 O(1)
  - LinkedHashMap
   - HashMap을 상속, LinkedList로 저장
   - 입력 순서대로 출력
   - 시간복잡도 O(n)
  - TreeMap
   - 키 값이 오름차순으로 되어있음
   - 키 값에대해 Comparator 구현으로 정렬할 수 있음
   - 시간복잡도 O(logn)
  - ConcurrentHashMap
   - multiple lock 지원
   - update할때 동기처리
   - key value 널 허용하지 않음
- Set : 집합 개념 , 순서 의미x, 데이터 중복 불가
  - HashSet
   - 저장 순서를 유지하지 않는 데이터 집합
   - 해시 알고리즘 사용 검색속도 빠름
   - 내부줙으로 HashMap 인스턴스 사용
  - TreeSet
   - 데이터 정렬된 상태로 저장(이진탐색트리)
   - Comparator 사용가능
- List : 순서가 있음, 데이터 중복가능
 - ArrayList
  - 단방향 포인터 구조로 데이터에 인덱스를 가지고잇음 검색에 용이
  - 삽입 삭제시 모든 데이터가 복사되므로 빈번한 데이터 삽입,삭제는 좋지안흠
 - LinkedList
  - 양방향 포인터 구조로 데이터 삽입,삭제 시 해당 노드의 주소지만 바꿔 삽입, 삭제가 빈번한 데이터에 적합
  - 데이터 검색 시 처음부터 노드 순회
  - 스택 큐 사용
 - Vector 
  - 내부에서 자동으로 동기화
  - 성능이 안좋음

  ## String, StringBuilder, StringBuffer
  - String
   - 새로운 값 할당할때마다 새로운 객체생성
   - final char[] 형태이기때문에 String 변경불가
   - String + String  +.. 메모리에 치명적
 - StringBuilder, StringBuffer
 - memory에 append 하는 방식
  - StringBuilder
   - 비동기처리
  - StringBuffer
   - 동기ㅓ리 멀티 스레드환경에서 안전

## 리플렉션
 - 자바에서 이미 로딩이 완료된 클래스에서 또다른 클래스를 동적로딩 하여 생성자, 메서드, 변수등을 사용할 수 있는 기법
 - 클래스의 패키지정보, 수퍼클래스, 어노테이션등을 얻을 수 있따.
 - 실행시간에 동적으로 특정 클래스 정보르객체를 분석

## 어노테이션
 - 주석이란 뜻으로 인터페이스 기반으로 한 문법
 - 주석처럼 코드에 달아 클래스를 의미를 부여하거나 기능을 주입할 수 있다.

 ## wrapper class
  - 기본자료형을 객체로 다루기위해 사용하는 클래스말한다. Integer, Float,Boolean 등
  - AutoBoxing
   - 자바 1.5부터 오토박싱, 오토언방식 제공
    - int -> Integer
    - Integer -> int

## 동기화
 - 스레드 간 경쟁상태를 통제
 - list -> vector, map->hashtable but 성능이 안좋음. ->concurrent pakage 구현체 제공하여 사용하면됨

